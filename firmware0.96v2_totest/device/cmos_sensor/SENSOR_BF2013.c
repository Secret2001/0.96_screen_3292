#include "cmos_sensor.h"

#if DEV_SENSOR_BF2013 > 0


SENSOR_INIT_SECTION const unsigned char BF2013InitTable[]=
{
/*
	0x01,// [7:0]:driver type,0x01:sensor whith ISP, 0x02:ISP, 0x03:sensor whithout isp,	
	
	0x01,0x6E,0x36,0x00,// [7:0]:XCLK(BE)
	0x00,0x01,0x86,0xA0,// [7:0]:BAUDRATE(BE)
	
	0x00,//	[7:0]:chip_ID_addr>>8,when AddrByteNum == 2, 0 when  AddrByteNum == 1
	0xfc,// [7:0]:chip_ID_addr
	0x00,// [7:0]:chip_ID  
	0x37,//
	0x00,0x00,0x00,0x00,//resverd
	
	0x02,0x80,//image_width
	0x01,0xE0,//image_height
	0xdd,// [7:0]:read ID
	0xdc,// [7:0]:write ID
	0x01,//	[7:0]:AddrByteNum , 
	0x01,// [7:0]:DataByteNum
	
	0x04,// [2:0]:ldo_config_para
	0x01,// [7:0]:ID nums
*/
			0x11,0x80,
			0x09,0x00,
			0x13,0x00,
			0x01,0x13,
			0x02,0x25,
			0x8c,0x02,//01 :devided by 2  02 :devided by 1
			0x8d,0xfd,//cb: devided by 2  fd :devided by 1
			0x87,0x1a,
			0x13,0x07,
			0x15,0x22,//POLARITY of Signal
			0x3a,0x00,  
			0x17, 0x01, //defaulf	13
			0x18, 0xa1, //defaulf	01
			0x19, 0x00, //defaulf	02
			0x1a, 0x78, //defaulf	7a
			0x03, 0xf0, //defaulf	0a
			//0x2a, 0x00,// Dummy pixel & dummy line 
			//0x2b, 0x00,  //add dummy pixel to 30fps//a
			//0x2d, 0x00,
			//0x2e, 0x00,  //add dummy line to 30fps
			//0x92, 0x00,
			//0x93, 0x00,  //add dummy line to 30fps
			0x35,0x68,//lens shading
			0x65,0x68,
			0x66,0x62,
			0x36,0x05,
			0x37,0xf6,
			0x38,0x46,
			0x9b,0xf6,
			0x9c,0x46,
			0xbc,0x01,
			0xbd,0xf6,
			0xbe,0x46,	
			0X1F,0x20,//G target //black level
			0X22,0x20,//R target
			0X26,0x20,//B target
			0x82,0x14,//AE
			0x83,0x23,
			0x9a,0x23,//the same as 0x83
			0x84,0x1a,
			0x85,0x20,
			0x89,0x04,//02 :devided by 2  04 :devided by 1
			0x8a,0x08,//04: devided by 2  05 :devided by 1
			0x86,0x28,//the same as 0x7b
			0x96,0xa6,//AE speed
			0x97,0x0c,//AE speed
			0x98,0x18,//AE speed
			0x24,0x8a,//µÆÏä²âÊÔ  0x6a  //AE target
			0x25,0x9a,//µÆÏä²âÊÔ  0x7a
			0x94,0x0a,//INT_OPEN  
			0x80,0x55,
			0x70,0x6f,//denoise 	//denoise 
			0x72,0x4f,//denoise
			0x73,0x2f,//denoise
			0x74,0x27,//denoise
			0x77,0x90,//È¥³ý¸ñ×ÓÔëÉù
			0x7a,0x0e,//denoise in low light,0x8e\0x4e\0x0e
			0x7b,0x28,//the same as 0x86
			0X16,0x00,//Èç¹û¾õµÃºÚÉ«ÎïÌå²»¹»ºÚ£¬ÓÐµãÆ«ºì£¬½«0x16Ð´Îª0x03»áÓÐµã¸ÄÉÆ   //Ä£Äâ²¿·Ö²ÎÊý
			0xbb,0x20, // deglitch  ¶ÔxclkÕûÐÎ
			0xeb,0x30,
			0xf5,0x21,
			0xe1,0x3c,
			0xbb,0x20,
			0X2f,0Xf6,
			0x06,0xe0,		
			0x61,0xd3,//0x61[3]=0 black sun disable //anti black sun spot
			0x79,0x48,//0x79[7]=0 black sun disable
			0x56,0x40, 		//contrast
			0x3b,0x60,//auto gamma offset adjust in  low light  //Gamma
			0x3c,0x20,//auto gamma offset adjust in  low light 
			0x39,0x80,
			0X3f,0Xb0,//gamma3 ÇåÎúÁÁÀö »Ò½×·Ö²¼ºÃ
			0X40,0X60,
			0X41,0X60,
			0X42,0X66,
			0X43,0X57,
			0X44,0X4c,
			0X45,0X43,
			0X46,0X3c,
			0X47,0X37,
			0X48,0X33,
			0X49,0X2f,
			0X4b,0X2c,
			0X4c,0X29,
			0X4e,0X25,
			0X4f,0X22,
			0X50,0X20,
			0x51,0x0e,// color  ÑÞÀö
			0x52,0x16,
			0x53,0x07,
			0x54,0x1a,
			0x57,0x9d,
			0x58,0x82,
			0x59,0x71,
			0x5a,0x8d,
			0x5b,0x1c,
			0x5D,0x95,
			0x5C,0x0e,
			0x60,0x20,//color open in low light 
			0x6a,0x01,//Èç¹û·ôÉ«Æ«É«£¬½«0x6aÐ´Îª0x81.//AWB
			0x23,0x66,//Green gain
			0xa0,0x07,//0xa0Ð´0x03£¬ºÚÉ«ÎïÌå¸üºì£»0xa0Ð´0x07£¬ºÚÉ«ÎïÌå¸üºÚ£»
			0xa1,0X41,//
			0xa2,0X0e,
			0xa3,0X26,
			0xa4,0X0d,
			0xa5,0x28,//The upper limit of red gain //ÀäÉ«µ÷
			0xa6,0x04,
			0xa7,0x80,//BLUE Target
			0xa8,0x80,//RED Target
			0xa9,0x28,
			0xaa,0x28,
			0xab,0x28,
			0xac,0x3c,
			0xad,0xf0,
			0xc8,0x18,
			0xc9,0x20,
			0xca,0x17,
			0xcb,0x1f,
			0xaf,0x00, 	  
			0xc5,0x18,   
			0xc6,0x00,
			0xc7,0x20,   
			0xae,0x83,//Èç¹ûÕÕ»§ÍâÆ«À¶£¬½«´Ë¼Ä´æÆ÷0xaeÐ´Îª0x81¡£
			0xcc,0x30,
			0xcd,0x70,
			0xee,0x4c,// P_TH
			0xb0,0xd0,// color saturation
			0xb1,0xd0, //c0
			0xb2,0xc0, //b0
			0xb3,0x88,
			0x9d,0x99,//0x4c
			0x8e,0x02,//0x01
			0x8f,0x64,//0xfe
			-1,-1
			//switch direction
			//0x1e,0x30,//00:normal	10:IMAGE_V_MIRROR	 

};

static void BF2013_rotate(u32 r)
{
	unsigned char buf[2];
	buf[0] = 0x1e;
	//buf[1] = Sensor_ReadRegister(buf,u8AddrLength,u8DataLength);
	//buf[1] &=~(3<<4);
	buf[1] = (r<<4)|0x00;
	sensor_iic_write(buf);
}

static void BF2013_hvblank(u32 h,u32 v)
{
	u32 i;
	const u8 t[][2] = {
		{0x2a,(h >> 8) << 4 },
		{0x2b,h & 0xff},
		{0x92,v & 0xff},
		{0x93,v >> 8},
		{0xe3,0x00},
		{0xe4,0},
	};
	
	for(i=0;i<6;i++)
		sensor_iic_write((u8 *)&t[i][0]);
}

SENSOR_OP_SECTION const Sensor_Op_t bf2013_cmd= 
{ 
	.typ = CSI_TYPE_YUV422,
	.pixelw = 640,
	.pixelh= 480,
	.hsyn = 1,
	.vsyn = 1,
	.rduline = 0,//
	.colrarray = 2,//0:_RGRG_ 1:_GRGR_,2:_BGBG_,3:_GBGB_
	.rotate_adapt = {0},
	.hvb_adapt = {0,0,0,0},
	. mclk = 24000000,
	.p_fun_adapt = {BF2013_rotate,BF2013_hvblank,NULL},
};


SENSOR_HEADER_ITEM_SECTION const Sensor_Init_t bf2013_init=
{
	.sensor_struct_addr = (u32 *)&bf2013_cmd, 
	.sensor_struct_size = sizeof(Sensor_Op_t),
	.sensor_init_tab_adr =	(u32 *)BF2013InitTable,     
	.sensor_init_tab_size = sizeof(BF2013InitTable),
	.id               = 0x37,               
	.w_cmd            = 0xdc,               
	.r_cmd            = 0xdd,               
	.addr_num         = 0x01,               
	.data_num         = 0x01,               
	.id_reg           = 0xfc,               
};



#endif



